package generator

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/sergei-svistunov/go-ssr/internal/config"
	"github.com/sergei-svistunov/go-ssr/internal/generator/gobuf"
	"github.com/sergei-svistunov/go-ssr/internal/generator/route"
)

const goFileHeader = "// Code generated by github.com/sergei-svistunov/go-ssr. DO NOT EDIT.\n"

type Generator struct {
	dir              string
	webDir           string
	webPkgName       string
	routes           map[string]*route.Route
	assets           *Assets
	projectCmd       *exec.Cmd
	projectCmdDone   chan struct{}
	projectCmdEnv    map[string]string
	goRunArgs        string
	genDataProviders bool
}

func New(cfg *config.Config) *Generator {
	return &Generator{
		dir:              cfg.Dir,
		webDir:           cfg.WebDir,
		webPkgName:       cfg.WebPackage,
		routes:           make(map[string]*route.Route),
		projectCmdEnv:    cfg.Env,
		goRunArgs:        cfg.GoRunArgs,
		genDataProviders: cfg.GenDataProviders,
	}
}

func (g *Generator) Analyze() error {
	g.routes = make(map[string]*route.Route)

	assets, err := AssetsFromDir(g.webDir)
	if err != nil {
		return err
	}
	g.assets = assets

	pagesDir := filepath.Join(g.webDir, "pages")
	if err := filepath.WalkDir(pagesDir, func(p string, d fs.DirEntry, err error) error {
		if !d.IsDir() {
			return nil
		}

		routePath, err := filepath.Rel(pagesDir, p)
		if err != nil {
			return fmt.Errorf("could not determine relative path for route: %w", err)
		}

		r, err := route.FromDir(p, func(file string) string {
			result := g.assets.GetImageAsset(path.Join(routePath, file))
			if result == "" {
				return file
			}
			return result
		})
		if err != nil {
			return err
		}

		g.routes[path.Join("/", routePath)] = r

		return nil
	}); err != nil {
		return err
	}

	return nil
}

func (g *Generator) Generate() error {
	if err := g.genHandler(); err != nil {
		return fmt.Errorf("could not generate handler: %w", err)
	}

	for rPath, r := range g.routes {
		if err := g.genRoute(rPath, r); err != nil {
			return fmt.Errorf("could not generate route %s: %w", rPath, err)
		}

		if err := g.genRouteDP(rPath, r); err != nil {
			return fmt.Errorf("could not generate route dataprovider %s: %w", rPath, err)
		}
	}

	if g.genDataProviders {
		dpFilename := filepath.Join(g.webDir, "dataprovider.go")
		if fileExists(dpFilename) {
			if err := g.updateDP(dpFilename); err != nil {
				return fmt.Errorf("could not patch dataprovider: %w", err)
			}
		} else {
			if err := g.genDP(dpFilename); err != nil {
				return fmt.Errorf("could not create dataprovider: %w", err)
			}
		}
	}

	return nil
}

func (g *Generator) getRoutesPaths() []string {
	paths := make([]string, 0, len(g.routes))
	for p := range g.routes {
		paths = append(paths, p)
	}
	sort.Strings(paths)

	return paths
}

func (g *Generator) genHandler() error {
	buf := gobuf.New()

	buf.WriteStringLn(goFileHeader)
	buf.WriteStringLn("package pages")

	buf.WriteStringLn("import (")
	buf.WriteQuotedString("net/http", "\n\n")
	buf.WriteQuotedString("github.com/sergei-svistunov/go-ssr/pkg/mux", "\n\n")
	for _, rPath := range g.getRoutesPaths() {
		if rPath == "/" {
			continue
		}
		buf.WriteString(getRoutePackageAlias(rPath))
		buf.WriteQuotedString(path.Join(g.webPkgName, "pages", rPath), "\n")
	}

	buf.WriteStringLn(")")

	// type DataProvider
	buf.WriteStringLn("type DataProvider interface {")
	for _, rPath := range g.getRoutesPaths() {
		if rPath != "/" {
			buf.WriteString(getRoutePackageAlias(rPath))
			buf.WriteString(".")
		}
		buf.WriteStringLn("RouteDataProvider")
	}
	buf.WriteStringLn("}")

	// func NewSsrHandler
	buf.WriteStringLn("func NewSsrHandler(dp DataProvider, opts mux.Options) http.Handler {")
	buf.WriteStringLn("return mux.New(dp, map[string]mux.Route[DataProvider]{")
	for _, rPath := range g.getRoutesPaths() {
		buf.WriteQuotedString(rPath)
		buf.WriteString(": ")
		if rPath != "/" {
			buf.WriteString(getRoutePackageAlias(rPath))
			buf.WriteString(".")
		}
		buf.WriteStringLn("Route[DataProvider]{},")
	}

	buf.WriteStringLn("}, opts)")
	buf.WriteStringLn("}")

	formattedCode, err := buf.Formatted()
	if err != nil {
		return fmt.Errorf("could not format generated code: %w", err)
	}

	if err := os.WriteFile(filepath.Join(g.webDir, "pages/ssrhandler_gen.go"), formattedCode, 0755); err != nil {
		return fmt.Errorf("could not write handler.go: %w", err)
	}

	return nil
}

func (g *Generator) genRoute(rPath string, r *route.Route) error {
	buf := gobuf.New()

	buf.WriteStringLn(goFileHeader)
	buf.WriteString("package ")
	buf.WriteStringLn(path.Base(path.Join("pages", rPath)))

	buf.WriteStringLn("import (")
	buf.WriteQuotedString("context", "\n")
	buf.WriteQuotedString("io", "\n\n")
	buf.WriteQuotedString("github.com/sergei-svistunov/go-ssr/pkg/mux", "\n")
	buf.WriteStringLn(")")

	routeVariables := r.Template().GetVariables()
	// type RouteData

	buf.WriteStringLn("type RouteData struct {")
	for _, variable := range routeVariables {
		buf.WriteString(getExportedName(variable.Name))
		buf.WriteString(" ")
		buf.WriteStringLn(variable.Type)
	}
	buf.WriteStringLn("}")
	buf.WriteString("\n")

	// RouteDataProvider
	buf.WriteStringLn("type RouteDataProvider interface{")
	buf.WriteString(getRouteDataProviderMethod(rPath))
	buf.WriteStringLn("(ctx context.Context, r *mux.Request, w mux.ResponseWriter, data *RouteData) error")

	if r.Template().GetContentNode() != nil && r.Template().GetContentNode().Default == "" {
		buf.WriteString(getRouteDefaultSubroute(rPath))
		buf.WriteStringLn("(ctx context.Context, r *mux.Request) (string, error)")
	}
	buf.WriteStringLn("}\n")

	// Route[DataProvider RouteRataProvider]
	buf.WriteStringLn("type Route[DataProvider RouteDataProvider] struct {}")

	// func (Route[DataProvider]) GetDataContext
	buf.WriteStringLn("func (Route[DataProvider]) GetDataContext(ctx context.Context, r *mux.Request, w mux.ResponseWriter, dp DataProvider, child mux.DataContext) (mux.DataContext, error) {")
	buf.WriteStringLn("var (")
	buf.WriteStringLn("dataCtx = &dataContext{RouteDataContext: mux.RouteDataContext{")
	buf.WriteStringLn("	Child:  child,")
	buf.WriteStringLn("	Assets: []string{")
	for _, asset := range g.assets.GetTags(rPath) {
		buf.WriteQuotedString(asset, ",\n")
	}
	buf.WriteStringLn("	},")
	buf.WriteStringLn("}}")
	buf.WriteStringLn(")")
	buf.WriteString("if err := dp.")
	buf.WriteString(getRouteDataProviderMethod(rPath))
	buf.WriteStringLn("(ctx, r, w, &dataCtx.RouteData); err != nil {")
	buf.WriteStringLn("return nil, err")
	buf.WriteStringLn("}")
	buf.WriteStringLn("return dataCtx, nil")
	buf.WriteStringLn("}")
	buf.WriteString("\n")

	// func (r Route[DataProvider]) GetDefaultSubRoute
	buf.WriteString("func (Route[DataProvider]) GetDefaultSubRoute(ctx context.Context, r *mux.Request, dp DataProvider) (string, error) { return ")
	if nodeContent := r.Template().GetContentNode(); nodeContent != nil {
		if nodeContent.Default == "" {
			buf.WriteString("dp.")
			buf.WriteString(getRouteDefaultSubroute(rPath))
			buf.WriteString("(ctx, r)")
		} else {
			buf.WriteQuotedString(nodeContent.Default)
			buf.WriteString(", nil")
		}
	} else {
		buf.WriteString(`"", nil`)
	}

	buf.WriteStringLn("}")

	// type dataContext
	buf.WriteStringLn("type dataContext struct {")
	buf.WriteStringLn("mux.RouteDataContext")
	buf.WriteStringLn("RouteData")
	buf.WriteStringLn("}")

	// func (c *dataContext) Write
	buf.WriteStringLn("func (c *dataContext) Write(w io.Writer) error {")
	for _, variable := range routeVariables {
		buf.WriteStringLn(variable.FilePos())
		buf.WriteString(variable.Name)
		buf.WriteString(":=c.RouteData.")
		buf.WriteStringLn(getExportedName(variable.Name))
	}
	r.Template().WriteGoCode(buf)
	buf.WriteStringLn("return nil")
	buf.WriteStringLn("}")

	buf.WriteVars()

	formattedCode, err := buf.Formatted()
	if err != nil {
		return fmt.Errorf("could not format generated code: %w\n%s", err, buf.String())
	}

	if err := os.WriteFile(filepath.Join(g.webDir, "pages", rPath, "ssrroute_gen.go"), formattedCode, 0755); err != nil {
		return fmt.Errorf("could not write route.go: %w", err)
	}

	return nil
}

func (g *Generator) genRouteDP(rPath string, r *route.Route) error {
	filename := filepath.Join(g.webDir, "pages", rPath, "dataprovider.go")
	if fileExists(filename) {
		// Already exists, skip
		return nil
	}

	buf := gobuf.New()
	dpTypeName := getRouteDataProviderName(rPath)

	buf.WriteString("package ")
	buf.WriteStringLn(path.Base(path.Join("pages", rPath)))

	buf.WriteStringLn("import (")
	buf.WriteQuotedString("context", "\n\n")
	buf.WriteQuotedString("github.com/sergei-svistunov/go-ssr/pkg/mux", "\n")
	buf.WriteStringLn(")")

	buf.WriteString("var _ RouteDataProvider = &")
	buf.WriteString(dpTypeName)
	buf.WriteStringLn("{}")

	buf.WriteString("type ")
	buf.WriteString(dpTypeName)
	buf.WriteStringLn(" struct{}")

	buf.WriteString("func NewDP() *")
	buf.WriteString(dpTypeName)
	buf.WriteStringLn(" {")
	buf.WriteString("	return &")
	buf.WriteString(dpTypeName)
	buf.WriteStringLn("{}")
	buf.WriteStringLn("}\n")

	buf.WriteString("func (p *")
	buf.WriteString(dpTypeName)
	buf.WriteString(") ")
	buf.WriteString(getRouteDefaultSubroute(rPath))
	buf.WriteStringLn("(ctx context.Context, r *mux.Request) (string, error) {")
	buf.WriteStringLn("	return \"\", nil")
	buf.WriteStringLn("}\n")

	buf.WriteString("func (p *")
	buf.WriteString(dpTypeName)
	buf.WriteString(") ")
	buf.WriteString(getRouteDataProviderMethod(rPath))
	buf.WriteStringLn("(ctx context.Context, r *mux.Request, w mux.ResponseWriter, data *RouteData) error {")
	buf.WriteStringLn("	return  nil")
	buf.WriteStringLn("}")

	formattedCode, err := buf.Formatted()
	if err != nil {
		return fmt.Errorf("could not format generated code: %w\n%s", err, buf.String())
	}

	if err := os.WriteFile(filename, formattedCode, 0755); err != nil {
		return fmt.Errorf("could not write dataprovider.go: %w", err)
	}

	return nil
}

func (g *Generator) genDP(filename string) error {
	buf := gobuf.New()

	buf.WriteString("package ")
	buf.WriteStringLn(path.Base(g.webPkgName))

	buf.WriteStringLn("import (")
	buf.WriteQuotedString(path.Join(g.webPkgName, "pages"), "\n")
	for _, rPath := range g.getRoutesPaths() {
		buf.WriteString(getRoutePackageAlias(rPath))
		buf.WriteQuotedString(path.Join(g.webPkgName, "pages", rPath), "\n")
	}

	buf.WriteStringLn(")")

	buf.WriteStringLn("func NewDataProvider() pages.DataProvider {")
	buf.WriteStringLn("	return &struct {")
	for _, rPath := range g.getRoutesPaths() {
		buf.WriteString("*")
		buf.WriteString(getRoutePackageAlias(rPath))
		buf.WriteString(".")
		buf.WriteStringLn(getRouteDataProviderName(rPath))
	}
	buf.WriteStringLn("}{")
	for _, rPath := range g.getRoutesPaths() {
		buf.WriteString(getRoutePackageAlias(rPath))
		buf.WriteStringLn(".NewDP(),")
	}
	buf.WriteStringLn("}")
	buf.WriteStringLn("}")

	formattedCode, err := buf.Formatted()
	if err != nil {
		return fmt.Errorf("could not format generated code: %w\n%s", err, buf.String())
	}

	if err := os.WriteFile(filename, formattedCode, 0755); err != nil {
		return fmt.Errorf("could not write dataprovider.go: %w", err)
	}

	return nil
}

func (g *Generator) updateDP(dpFilename string) error {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, dpFilename, nil, 0)
	if err != nil {
		return err
	}

	imports := map[string]*ast.Ident{}
	for _, importSpec := range f.Imports {
		imports[importSpec.Path.Value] = importSpec.Name
	}

	var (
		x       *ast.CompositeLit
		genDecl *ast.GenDecl
	)

	ast.Inspect(f, func(n ast.Node) bool {
		if d, ok := n.(*ast.GenDecl); ok {
			genDecl = d
			return false
		}

		if funcDecl, ok := n.(*ast.FuncDecl); ok && funcDecl.Name.Name == "NewDataProvider" {
			ast.Inspect(funcDecl.Body, func(n ast.Node) bool {
				if returnStmt, ok := n.(*ast.ReturnStmt); ok {
					if len(returnStmt.Results) > 0 {
						ast.Inspect(returnStmt.Results[0], func(n ast.Node) bool {
							if compositeLit, ok := n.(*ast.CompositeLit); ok {
								x = compositeLit
								return false
							}
							return true
						})
					}
					return false
				}
				return true
			})
			return false
		}
		return true
	})

	if x == nil {
		return fmt.Errorf("unable to find the NewDataProvider function or returning structure in it")
	}

	dataProviders := map[string]struct{}{}
	for _, field := range x.Type.(*ast.StructType).Fields.List {
		t, ok := field.Type.(*ast.StarExpr)
		if !ok {
			continue
		}
		expr, ok := t.X.(*ast.SelectorExpr)
		if !ok {
			continue
		}
		dataProviders[expr.Sel.Name] = struct{}{}
	}

	for rPath := range g.routes {
		pkgPath := `"` + path.Join(g.webPkgName, "pages", rPath) + `"`
		pkgAlias := getRoutePackageAlias(rPath)
		if _, exists := imports[pkgPath]; !exists {
			alias := &ast.Ident{
				Name: getRoutePackageAlias(rPath),
			}
			genDecl.Specs = append(genDecl.Specs, &ast.ImportSpec{
				Name: alias,
				Path: &ast.BasicLit{
					Kind:  token.STRING,
					Value: pkgPath,
				},
			})
			imports[pkgPath] = alias
		}

		dpName := getRouteDataProviderName(rPath)
		if _, exists := dataProviders[dpName]; !exists {
			x.Type.(*ast.StructType).Fields.List = append(x.Type.(*ast.StructType).Fields.List, &ast.Field{
				Type: &ast.StarExpr{
					X: &ast.SelectorExpr{
						X: &ast.Ident{
							Name: pkgAlias,
						},
						Sel: &ast.Ident{
							Name: dpName,
						},
					},
				},
			})
			x.Elts = append(x.Elts,
				&ast.CallExpr{
					Fun: &ast.SelectorExpr{
						X: &ast.Ident{
							Name: pkgAlias,
						},
						Sel: &ast.Ident{
							Name: "NewDP",
						},
					},
					Args: []ast.Expr{},
				},
			)
		}
	}

	outF, err := os.Create(dpFilename + "~")
	if err != nil {
		return err
	}
	if err := format.Node(outF, fset, f); err != nil {
		return err
	}
	outF.Close()

	if err := os.Remove(dpFilename); err != nil {
		return err
	}

	if err := os.Rename(dpFilename+"~", dpFilename); err != nil {
		return err
	}

	return nil
}

func pathToVariable(path string) string {
	if path == "" || path == "/" {
		return "_"
	}

	var res string

	for _, segment := range strings.Split(path, "/") {
		if segment == "" {
			continue
		}

		res += strings.ToUpper(string(segment[0])) + segment[1:]
	}

	return res
}

func getRouteDataProviderName(rPath string) string {
	if rPath == "" || rPath == "/" {
		return "RootDP"
	}

	return pathToVariable(rPath) + "DP"
}

func getRouteDataProviderMethod(rPath string) string {
	if rPath == "" || rPath == "/" {
		return "GetRouteRootData"
	}

	return "GetRoute" + pathToVariable(rPath) + "Data"
}

func getRouteDefaultSubroute(rPath string) string {
	if rPath == "" || rPath == "/" {
		return "GetRouteDefaultSubRoute"
	}

	return "GetRoute" + pathToVariable(rPath) + "DefaultSubRoute"
}

func getRoutePackageAlias(rPath string) string {
	return "route" + pathToVariable(rPath)
}

func getExportedName(name string) string {
	if name == "" {
		return ""
	}
	return strings.ToUpper(string(name[0])) + name[1:]
}

func fileExists(filename string) bool {
	_, err := os.Stat(filename)
	return err == nil
}

func fileTime(filename string) (time.Time, error) {
	stat, err := os.Stat(filename)
	if err != nil {
		return time.Time{}, err
	}
	return stat.ModTime(), nil
}
